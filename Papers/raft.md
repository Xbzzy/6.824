# In search of an understandable consensus algorithm-Extended Version(Raft一致性算法理解及实现)
## raft一致性算法概要
raft算法通过先选举出一个可靠的领袖者(leader)来实现其相应的共识性(consensus)，领袖者具有复制相应日志(replicated log)到对应的状态机(state machines)的责任。领袖者从客户端接收
日志记录(log entry)，然后将其复制到其他服务器，并且通知服务器何时才可以安全同步到对应的状态机；选举领袖者是简化了复制日志的流程，因为领袖者拥有新日志记录的决定权，无需再跟
其他服务器通过消息传递来商量处理结果，这大大提升了数据处理的效率。并且在系统中就算领袖者crash or fail，依旧可以通过选举系统选出一个新领袖者。<br>
<br>
raft算法把整个共识问题分解成了三个相应的子问题，这将会在后面的内容中逐步提到，这里先给出简要介绍：<br>
**领袖者选举(leader election)**：确保当前领袖者出现异常的情况下能立刻选出新领袖者，不会出现服务空档。<br>
**日志复制(log replication)**：领袖者从客户端处接收到日志记录请求，通过集群复制，保证其他服务器日志的一致性。<br>
**安全性(safety)**：raft通过一些状态机的安全属性来保证整体系统的安全性，例如如果有服务器在其状态机上同步了一些在其他服务器相应日志索引上不一样的日志记录，之后会单独描述怎样应对这种
情况；解决方案包括了对选举机制的重构。<br>
<br>
## raft实例状态介绍
先通过了解当前raft初始化后所含有的状态参数，从而结合之后的选举过程以及日志复制统一过程便于更好理解。<br>
**稳定性状态：**<br>

## 领袖者选举
raft算法为了保证系统中任意时刻总会有领袖者在任期即稳定高可用性，故在election过程中提出了一些关于选举的新概念，此做出简要介绍：<br>
每个raft实例可以扮演的角色：**领袖者(leader)**、**候选者(candidate)**、**随从者(follower)**,leader主要任务是通过统治性保证集群日志一致性；candidate则是在适宜时刻开启新一轮选举以防止当前leader出现异常或任期到期，作为及时补充；follower需要保持自身日志稳定性，且通过及时回复leader亦或candidate发到的RPC(远程过程调用)以保证系统稳定运行，如若察觉当前leader有可能陷入异常或网络阻塞，及时转换身份到candidate从而作为补充力量。<br>
每次任一实例开启选举后所在的时期：**任期(term)**，raft将各个不同选举阶段通过时间分割为多个任期，实例开启自己的新一轮选举则会开启新的任期。<br>
每个实例暴露给其他服务器的"端口"：**同辈(peer)**，发送RPC过程中通过访问对应服务器的端口实现通信及远程函数调用，所有服务器端口(包括自己)都存储在当前实例内存中。<br>









